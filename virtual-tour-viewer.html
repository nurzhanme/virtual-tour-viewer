<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D –í–∏—Ä—Ç—É–∞–ª—å–Ω—ã–π –¢—É—Ä –ö–≤–∞—Ä—Ç–∏—Ä—ã</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #1a1a1a;
        }
        
        #tour-container {
            width: 100vw;
            height: 100vh;
        }
        
        #instructions {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.85);
            color: white;
            padding: 20px 25px;
            border-radius: 12px;
            z-index: 100;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 300px;
            transition: opacity 0.3s ease;
        }
        
        #instructions.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        #instructions h3 {
            margin: 0 0 15px 0;
            font-size: 18px;
            font-weight: 600;
        }
        
        #instructions p {
            margin: 8px 0;
            font-size: 14px;
            line-height: 1.5;
        }
        
        #watermark {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 8px;
            z-index: 100;
            font-size: 13px;
            backdrop-filter: blur(5px);
        }
        
        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 40px 60px;
            border-radius: 15px;
            z-index: 200;
            text-align: center;
            backdrop-filter: blur(10px);
        }
        
        #loading h2 {
            margin: 0 0 15px 0;
            font-size: 24px;
        }
        
        .spinner {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-top: 3px solid white;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto 0;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #error {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(220, 53, 69, 0.95);
            color: white;
            padding: 30px 50px;
            border-radius: 12px;
            z-index: 300;
            text-align: center;
            max-width: 400px;
        }
        
        #controls-info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 8px 15px;
            border-radius: 8px;
            z-index: 100;
            font-size: 12px;
            backdrop-filter: blur(5px);
        }
    </style>
</head>
<body>
    <div id="tour-container"></div>
    
    <div id="instructions">
        <h3>üéÆ –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ</h3>
        <p>üñ±Ô∏è <strong>–ú—ã—à—å</strong> - –≤—Ä–∞—â–µ–Ω–∏–µ –∫–∞–º–µ—Ä—ã</p>
        <p>‚å®Ô∏è <strong>W/A/S/D</strong> - –¥–≤–∏–∂–µ–Ω–∏–µ</p>
        <p>‚¨ÜÔ∏è <strong>–°—Ç—Ä–µ–ª–∫–∏</strong> - –¥–≤–∏–∂–µ–Ω–∏–µ</p>
        <p>üñ±Ô∏è <strong>–ö–æ–ª–µ—Å–∏–∫–æ</strong> - –ø—Ä–∏–±–ª–∏–∂–µ–Ω–∏–µ</p>
    </div>
    
    <div id="controls-info">
        –í—ã—Å–æ—Ç–∞ –∫–∞–º–µ—Ä—ã: 1.6–º | –°–∫–æ—Ä–æ—Å—Ç—å: —Å—Ä–µ–¥–Ω—è—è
    </div>
    
    <div id="watermark">
        Powered by nurzhanme
    </div>
    
    <div id="loading">
        <h2>–ó–∞–≥—Ä—É–∑–∫–∞ 3D-—Ç—É—Ä–∞</h2>
        <p>–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–æ–∂–¥–∏—Ç–µ...</p>
        <div class="spinner"></div>
    </div>
    
    <div id="error">
        <h2>‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏</h2>
        <p id="error-message"></p>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        class VirtualTourViewer {
            constructor(containerId) {
                this.container = document.getElementById(containerId);

                // –°—Ü–µ–Ω–∞
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0xf0f0f0);

                // –ö–∞–º–µ—Ä–∞
                this.camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                this.camera.position.set(0, 0.96, 5); // –í—ã—Å–æ—Ç–∞ –∫–∞–º–µ—Ä—ã (1.6–º - 40%)

                // Renderer
                this.renderer = new THREE.WebGLRenderer({
                    antialias: true,
                    alpha: true
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.shadowMap.enabled = true;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                this.container.appendChild(this.renderer.domElement);

                // OrbitControls –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –º—ã—à—å—é
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;
                this.controls.minDistance = 1;
                this.controls.maxDistance = 50;
                this.controls.maxPolarAngle = Math.PI / 2; // –ù–µ –¥–∞–µ–º —Å–º–æ—Ç—Ä–µ—Ç—å –ø–æ–¥ –ø–æ–ª
                this.controls.enablePan = false; // –û—Ç–∫–ª—é—á–∞–µ–º pan –ø—Ä–∞–≤–æ–π –∫–Ω–æ–ø–∫–æ–π

                // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–≤–∏–∂–µ–Ω–∏—è
                this.moveSpeed = 0.15; // –°–∫–æ—Ä–æ—Å—Ç—å –¥–≤–∏–∂–µ–Ω–∏—è
                this.keys = {};
                this.clock = new THREE.Clock();

                this.setupLights();
                this.setupEventListeners();
                this.setupGrid(); // –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ: —Å–µ—Ç–∫–∞ –¥–ª—è –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏–∏
            }
            
            setupLights() {
                // Ambient light
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);
                
                // Directional light (–∫–∞–∫ —Å–æ–ª–Ω—Ü–µ)
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 20, 10);
                directionalLight.castShadow = true;
                directionalLight.shadow.camera.left = -20;
                directionalLight.shadow.camera.right = 20;
                directionalLight.shadow.camera.top = 20;
                directionalLight.shadow.camera.bottom = -20;
                this.scene.add(directionalLight);
                
                // Hemisphere light –¥–ª—è –±–æ–ª–µ–µ –µ—Å—Ç–µ—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ –æ—Å–≤–µ—â–µ–Ω–∏—è
                const hemisphereLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.4);
                this.scene.add(hemisphereLight);
            }
            
            setupGrid() {
                // –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–∞—è —Å–µ—Ç–∫–∞ –¥–ª—è –æ—Ç–ª–∞–¥–∫–∏ (–º–æ–∂–Ω–æ —É–±—Ä–∞—Ç—å)
                const gridHelper = new THREE.GridHelper(20, 20, 0xcccccc, 0xeeeeee);
                gridHelper.visible = false; // –°–∫—Ä—ã—Ç–∞ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
                this.scene.add(gridHelper);
                
                // –ü–æ–∫–∞–∑–∞—Ç—å —Å–µ—Ç–∫—É –ø–æ –Ω–∞–∂–∞—Ç–∏—é G
                document.addEventListener('keydown', (e) => {
                    if (e.code === 'KeyG') {
                        gridHelper.visible = !gridHelper.visible;
                    }
                });
            }
            
            setupEventListeners() {
                // Keyboard controls
                document.addEventListener('keydown', (e) => {
                    this.keys[e.code] = true;
                });
                
                document.addEventListener('keyup', (e) => {
                    this.keys[e.code] = false;
                });
                
                // Window resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
                
                // –°–∫—Ä—ã—Ç—å –∏–Ω—Å—Ç—Ä—É–∫—Ü–∏–∏ —á–µ—Ä–µ–∑ 8 —Å–µ–∫—É–Ω–¥
                setTimeout(() => {
                    document.getElementById('instructions').classList.add('hidden');
                }, 8000);
            }
            
            async loadModel(url) {
                const loader = new GLTFLoader();

                try {
                    // –ó–∞–≥—Ä—É–∂–∞–µ–º —Ñ–∞–π–ª —á–µ—Ä–µ–∑ fetch, —á—Ç–æ–±—ã –æ–±–æ–π—Ç–∏ –ø—Ä–æ–±–ª–µ–º—É —Å computer:// –ø—Ä–æ—Ç–æ–∫–æ–ª–æ–º
                    const response = await fetch(url);
                    const blob = await response.blob();
                    const blobUrl = URL.createObjectURL(blob);

                    return new Promise((resolve, reject) => {
                        loader.load(
                            blobUrl,
                            (gltf) => {
                                // –û—á–∏—â–∞–µ–º blob URL
                                URL.revokeObjectURL(blobUrl);

                                // –î–æ–±–∞–≤–ª—è–µ–º –º–æ–¥–µ–ª—å –≤ —Å—Ü–µ–Ω—É
                                this.scene.add(gltf.scene);

                                // –í–∫–ª—é—á–∞–µ–º —Ç–µ–Ω–∏ –¥–ª—è –≤—Å–µ—Ö mesh'–µ–π
                                gltf.scene.traverse((child) => {
                                    if (child.isMesh) {
                                        child.castShadow = true;
                                        child.receiveShadow = true;
                                    }
                                });

                                // –¶–µ–Ω—Ç—Ä–∏—Ä—É–µ–º –º–æ–¥–µ–ª—å
                                const box = new THREE.Box3().setFromObject(gltf.scene);
                                const center = box.getCenter(new THREE.Vector3());
                                gltf.scene.position.x = -center.x;
                                gltf.scene.position.z = -center.z;

                                console.log('‚úÖ –ú–æ–¥–µ–ª—å —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω–∞');
                                resolve(gltf);
                            },
                            (progress) => {
                                const percent = (progress.loaded / progress.total * 100).toFixed(0);
                                console.log(`–ó–∞–≥—Ä—É–∑–∫–∞: ${percent}%`);
                            },
                            (error) => {
                                URL.revokeObjectURL(blobUrl);
                                console.error('‚ùå –û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –º–æ–¥–µ–ª–∏:', error);
                                reject(error);
                            }
                        );
                    });
                } catch (error) {
                    console.error('‚ùå –û—à–∏–±–∫–∞ fetch:', error);
                    throw error;
                }
            }
            
            updateMovement() {
                const direction = new THREE.Vector3();
                const right = new THREE.Vector3();

                // –ü–æ–ª—É—á–∞–µ–º –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–∞–º–µ—Ä—ã (–≤–ø–µ—Ä–µ–¥)
                this.camera.getWorldDirection(direction);
                direction.y = 0; // –ù–µ –¥–∞–µ–º –ª–µ—Ç–∞—Ç—å –≤–≤–µ—Ä—Ö/–≤–Ω–∏–∑
                direction.normalize();

                // –í—ã—á–∏—Å–ª—è–µ–º –ø—Ä–∞–≤—ã–π –≤–µ–∫—Ç–æ—Ä (–¥–ª—è A/D)
                right.crossVectors(direction, new THREE.Vector3(0, 1, 0)).normalize();

                const rotationSpeed = 0.03; // –°–∫–æ—Ä–æ—Å—Ç—å –ø–æ–≤–æ—Ä–æ—Ç–∞

                // W / Arrow Up - –≤–ø–µ—Ä–µ–¥
                if (this.keys['KeyW'] || this.keys['ArrowUp']) {
                    this.camera.position.addScaledVector(direction, this.moveSpeed);
                    this.controls.target.addScaledVector(direction, this.moveSpeed);
                }

                // S / Arrow Down - –Ω–∞–∑–∞–¥
                if (this.keys['KeyS'] || this.keys['ArrowDown']) {
                    this.camera.position.addScaledVector(direction, -this.moveSpeed);
                    this.controls.target.addScaledVector(direction, -this.moveSpeed);
                }

                // A - –≤–ª–µ–≤–æ (—Å—Ç—Ä–µ–π—Ñ)
                if (this.keys['KeyA']) {
                    this.camera.position.addScaledVector(right, -this.moveSpeed);
                    this.controls.target.addScaledVector(right, -this.moveSpeed);
                }

                // D - –≤–ø—Ä–∞–≤–æ (—Å—Ç—Ä–µ–π—Ñ)
                if (this.keys['KeyD']) {
                    this.camera.position.addScaledVector(right, this.moveSpeed);
                    this.controls.target.addScaledVector(right, this.moveSpeed);
                }

                // Arrow Left - –ø–æ–≤–æ—Ä–æ—Ç –≤–ª–µ–≤–æ
                if (this.keys['ArrowLeft']) {
                    const offset = this.controls.target.clone().sub(this.camera.position);
                    offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), rotationSpeed);
                    this.controls.target.copy(this.camera.position).add(offset);
                }

                // Arrow Right - –ø–æ–≤–æ—Ä–æ—Ç –≤–ø—Ä–∞–≤–æ
                if (this.keys['ArrowRight']) {
                    const offset = this.controls.target.clone().sub(this.camera.position);
                    offset.applyAxisAngle(new THREE.Vector3(0, 1, 0), -rotationSpeed);
                    this.controls.target.copy(this.camera.position).add(offset);
                }

                // –§–∏–∫—Å–∏—Ä—É–µ–º –≤—ã—Å–æ—Ç—É –∫–∞–º–µ—Ä—ã (–Ω–µ –¥–∞–µ–º "–ø—Ä–æ–≤–∞–ª–∏–≤–∞—Ç—å—Å—è" –ø–æ–¥ –ø–æ–ª)
                this.camera.position.y = Math.max(this.camera.position.y, 0.96);
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                this.updateMovement();
                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            }
            
            start() {
                this.animate();
            }
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
        async function init() {
            const loading = document.getElementById('loading');
            const errorDiv = document.getElementById('error');
            const errorMessage = document.getElementById('error-message');
            
            try {
                // –°–æ–∑–¥–∞–µ–º viewer
                const viewer = new VirtualTourViewer('tour-container');
                
                // –ó–∞–≥—Ä—É–∂–∞–µ–º –≤–∞—à—É –º–æ–¥–µ–ª—å
                const modelUrl = '19.11.2025.glb';
                
                // –ï—Å–ª–∏ –Ω—É–∂–Ω–æ –ø–æ–ª—É—á–∏—Ç—å URL —Å –±—ç–∫–µ–Ω–¥–∞:
                // const tourId = new URLSearchParams(window.location.search).get('id');
                // const response = await fetch(`/api/tours/${tourId}/view`);
                // const data = await response.json();
                // const modelUrl = data.modelUrl;
                
                await viewer.loadModel(modelUrl);
                viewer.start();
                
                loading.style.display = 'none';
                
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞:', error);
                loading.style.display = 'none';
                errorDiv.style.display = 'block';
                errorMessage.textContent = error.message || '–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å 3D-—Ç—É—Ä';
            }
        }

        // –ó–∞–ø—É—Å–∫ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
        init();
    </script>
</body>
</html>